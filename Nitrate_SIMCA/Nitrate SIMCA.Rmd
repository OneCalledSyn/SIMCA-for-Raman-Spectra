---
title: "<center>Exploratory Nitrate SIMCA</center>"
author: "<center>Jay Shapiro</center>"
date: "<center>1/13/2020</center>"
output: 
  html_document:
    theme: cerulean
  pdf_document: default  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br><br>

Topic: How can B&W Tek LLC improve its proprietary chemometric modeling software, BWIQ, so that SIMCA models share more information with end customers both analyticall and graphically?

<br><br>

## Introduction

<br><br>

**Soft independent modelling of class analogies** (SIMCA) is a supervised classification technique that is commonly used in fields such as chemometrics and spectroscopy. One of the noteworthy aspects of SIMCA is that samples can be identified as belonging to multiple classes, which is what the word "soft" references. For each class of samples, run PCA on the observations for dimensionality reduction purposes. Each modeled class will be described by a **flat affine n-dimensional subspace**, with n being the number of principal components in the model. For a single principal component, model the class using a line; for two principal components, model the class using a plane. For three or more principal components, the class model is going to be a hyperplane. Next, calculate the mean **orthogonal distance** (OD) from the training set to the flat affine n-dimensional subspace and use that number to determine the threshold for classification, called the **critical distance**, which is found with the F-distribution. Now that each class has a dimensionally reduced model and a classification threshold, new observations may be tested against the classifier model. 

<br><br>

### Exploration

<br><br>

The current iteration of BWIQ only gives the end user an accuracy value and a barebones plot after building a SIMCA model. In this exploration, I will employ and explain several analytical and graphical techniques that convey valubale information about the SIMCA model using spectra collected from a sample of calcium nitrate and a sample of magnesium nitrate with a NanoRam 785 nm device. One of the first things we can do after building the SIMCA model is use the summary() function in R to receive some enlightening statistics about the class model for calcium nitrate: 

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
library(tidyverse)
library(ggplot2)
library(plotly)
library(plyr)
library(data.table)
library(readr)
library(dplyr)
library(ggfortify)
library(factoextra)
library(mdatools)



#Grab the file names of the 20 spectra for 785nm measured Calcium Nitrate
myfiles <- list.files(path = "C:/Users/jays/Desktop/Converted_Spectra/785/Ca_Nitrate", 
                      pattern = "*.txt", full.names = TRUE)

#Instantiate an empty data frame to jam the raw data into
ca_nitrate_785 <- data.frame()

#Loop through the files to build one dataframe
for (lambda in c(1:20)) {
  location <- myfiles[lambda]
  temp <- fread(file = location, 
                sep = ";", fill = TRUE, header = TRUE) %>% select(`Dark Subtracted`)
  
  temp <- transpose(temp)
  
  ca_nitrate_785[lambda, 1:582] <- temp
}

#Instantiate an empty data frame to jam the raw data into
mg_nitrate_785 <- data.frame()

#Repeat above steps for the 20 spectra of 785nm measured Magnesium Nitrate
myfiles <- list.files(path = "C:/Users/jays/Desktop/Converted_Spectra/785/Mg_Nitrate", 
                      pattern = "*.txt", full.names = TRUE)

#Loop through the files
for (lambda in c(1:20)) {
  location <- myfiles[lambda]
  temp <- fread(file = location, 
                sep = ";", fill = TRUE, header = TRUE) %>% select(`Dark Subtracted`)
  
  temp <- transpose(temp)
  
  mg_nitrate_785[lambda, 1:582] <- temp
}

ca_calibration <- ca_nitrate_785[5:20, ]
mg_calibration <- mg_nitrate_785[5:20, ]

#Slap on an identification column
ca_nitrate_785 <- ca_nitrate_785 %>% mutate(compound = "ca")
mg_nitrate_785 <- mg_nitrate_785 %>% mutate(compound = "mg")

#Create a master dataframe of all 40 spectra
all_785_spectra <- rbind(ca_nitrate_785, mg_nitrate_785)

#Remove outlier
all_785_spectra <- all_785_spectra[-c(24), ]

ca_model <- simca(ca_calibration, 'calcium nitrate', ncomp = 3, cv = 1, center = TRUE, scale = TRUE)

summary(ca_model)
```

<br><br>

Next, we can call the very simple plot() function on the calcium nitrate model object and get several informative statistics: 

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
plot(ca_model)
```

<br><br>

In terms of SIMCA, the **scores** (also called **factor scores** or **component scores**) are the transformed variable values corresponding to particular data points. Another way to describe score is *the distance between the point an observation is projected onto the principal component axis and the origin*. 

<br><br>

**Modelling power** shows the amount each variable contributes to the variation described by the principal components. The default representation in plot() is cluttered by each variable name being displayed over the vertical bars because there are so many variables in spectral data.

<br><br>

**Squared residual distance** (Q) and **Hotelling's T-squared** are summary statistics typically used in factor-based models, which explain how well a model describes a given observation and assist with outlier detection. Q residual uses the sum of squares of each observation in the error matrix, which means the Q residual measures the difference between an observation and its projection into the space defined by the principal component eigenvectors. For the ith observation, calculate the Q residual using the following formula, where $e_i$ is the ith row of the error matrix E:

<br><br>

$$Q_i = e_ie_i^T$$

Hotelling's T-squared statistic uses the sum of normalized squared scores, which means it measures the variation within each observation in the PCA class model. Therefore, T-squared gives the distance between the projection of the observation onto the principal component eigenvectors and the multivariate mean. The Hotelling distribution is as follows, where S is the sample covariance matrix:

<br><br>

$$T^2 = (\bar{x} - \mu_0)^T S^{-1} (\bar{x} - \mu_0)$$

<br><br>

In summary, Q residuals demonstrate the magnitude of variation left in each observation after the observation is projected through the model, while Hotelling's T-squared represent the distance each observation is from the center of the class model (scores = 0).

<br><br>

The cumulative variance plot is fairly straightforward; it shows the total percentage of the variation in the data that is explained using increasing numbers of principal components.

<br><br>

Finally, we can check out an interactive visualization of the scores for the calcium nitrate model class mapped in ‚Ñù^3^ using the first three eigenvector axes:

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
plotme_ca <- data.frame(ca_model$calres$scores)

caplotly <- plot_ly(data = plotme_ca, x = ~Comp.1, y = ~Comp.2, z = ~Comp.3) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC 1'),
                      yaxis = list(title = 'PC 2'),
                      zaxis = list(title = 'PC 3')),
         title = "Calcium Nitrate Class Scores")

caplotly
```

Now we must do the same steps for the magnesium nitrate class model:

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
mg_model <- simca(mg_calibration, 'magnesium nitrate', ncomp = 3, cv = 1, center = TRUE, scale = TRUE)

summary(mg_model)
plot(mg_model)

plotme_mg <- data.frame(mg_model$calres$scores)

mgplotly <- plot_ly(data = plotme_mg, x = ~Comp.1, y = ~Comp.2, z = ~Comp.3) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC 1'),
                      yaxis = list(title = 'PC 2'),
                      zaxis = list(title = 'PC 3')),
         title = "Magnesium Nitrate Class Scores")

mgplotly
```

<br><br>

We can take the single-class SIMCA models for magnesium nitrate and calcium nitrate and combine them into a simcam object using the aptly named simcam() function in the mdatools package, which allows for SIMCA multiclass classification.

<br><br>

```{r warning = FALSE, message = FALSE}
nitrates <- simcam(models = list(ca_model, mg_model), info = 'Nitrate SIMCA')
```

<br><br>

Again, we will run the summary() function to get a cursory look at our model object:

```{r message = FALSE, warning = FALSE}
summary(nitrates)
```

<br><br>

We can see that taking a summary of the simcam model object basically just pastes the summaries from the individual SIMCA model classes together. There isn't much information gained, but it does offer utility in the organizational sector. A **Cooman's plot** is a common way to graphically display the results for SIMCA. Cooman's plots do pairwise comparison of the SIMCA classes by examining the distance from each observation in one class to the model of the other class. The plot is broken up into four regions with each region having a distinct meaning. Observations which are judged to belong to either of the two classes but not both classes fall in either the top left or the bottom right sectors, depending on which class they are determined to be in. Observations which are determined to fall into both classes will be in the bottom left sector, and observations which don't belong to either class will appear in the top right sector.

<br><br>

```{r echo = FALSE, message = FALSE, warning = FALSE}
plotCooman(nitrates)
```

<br><br>

Cooman's plots are fairly useful for a small number of SIMCA classes, but it's important to keep in mind that the number of plots required to examine all class pairings grows in quadratic time. Examining n SIMCA classes in such a manner will require $\frac{n(n-1)}{2}$ Cooman's plots. For situations where there are many classes to examine, it will be prohibitively difficult to examine the myriad plots in a reasonable amount of time.

The discrimination power plot tells us which variables in the observations contributed the most to separating the classes. Since the observations are spectral data, the discrimination power should be the greatest for the variables which are pixels of the main peaks of the Raman spectra. Similarly, discrimination power plots are created pair-wise between two classes at a time, so the number of plots will again grow quadratically as the number of classes increases.

```{r echo = FALSE, message = FALSE, warning = FALSE}
plotDiscriminationPower(nitrates, ylab = "Power", xlab = "Variable")
```

<br><br>

We can use the versatile predict() function to run our calibration set against the SIMCA model and see a visual representation of the class predictions: 

<br><br>

![](C:/Users/jays/Desktop/Nitrate_SIMCA/CalPredictions.png)

<br><br>
```{r echo = FALSE, message = FALSE, warning = FALSE}
ca_test <- ca_nitrate_785[1:4, ]
mg_test <- mg_nitrate_785[1:4, ]

nitrate_calibration <- rbind(ca_calibration, mg_calibration)
nitrate_test <- rbind(ca_test, mg_test)

results <- predict(nitrates, nitrate_calibration)
```

<br><br>

We can also do the same thing with the test set to get predictions against data not used to build the SIMCA class models: ![](C:/Users/jays/Desktop/Nitrate_SIMCA/TestPredictions.png)

<br><br>

A confusion matrix is another useful tool for letting a user know about the performance of their classification model, giving the number of false positives, false negatives, true positives, and true negatives. From these results, one can calculate several other measures of model performance such as sensitivity, specificity, F1 score, and accuracy. Here is an example of a confusion matrix for the calibration set: 

<br><br>

```{r echo = FALSE, message = FALSE, warning = FALSE}
getConfusionMatrix(nitrates$calres)
```

<br><br>

A user could see that all of the samples were correctly identified as either a true positive or a true negative and that there were no misclassifications in this case.

<br><br>

### Conclusion

<br><br>

The methods which I have outlined in this overview should be sufficient to satisfy the needs of both customers and internal employees alike. I highly recommend adding the plots and analytics discussed in this reprt to the BWIQ software. 

<br><br>

###                                                            IDE Info

<br><br>

```{r echo = FALSE}
sessionInfo()
```